#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.4
#  in conjunction with Tcl version 8.6
#    Oct 10, 2022 11:27:14 AM CST  platform: Windows NT

import sys
import time
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from PLC import *
from datetime import date
from datetime import datetime
import math
import OVEN
from dial_guage import dial_guage

WIDTH, HEIGHT = 500, 500
text_colour = "white"

bck_colour = "grey35"

scanner_neutral = "grey85"



def dark_mode():
    global bck_colour ,text_colour,scanner_neutral
    bck_colour = "black"
    text_colour="grey75"
    scanner_neutral = "lawn green"
    return 0

def light_mode():
    global bck_colour ,text_colour,scanner_neutral
    bck_colour = "grey75"
    text_colour="green"
    scanner_neutral="grey85"
    return 0

def draw_PLC_error(canvas,width,height):
    canvas.create_text(width/2,height/2,text="PLC Error",justify='center',fill="red",font="Times 100 bold")


def draw_alarm_alert(canvas,width,height):
    canvas.create_text(240,300,text="!!!ALARM!!!",justify='center',fill="red",font="Times 50 bold")



class Point:
    """convenience for point arithmetic"""
    def __init__(self, x, y):
        self.x, self.y = x, y
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    def __iter__(self):
        yield self.x
        yield self.y


class RegularPolygon:

    def __init__(self, num_sides, bbox_side, x, y):   # x, y are bbox center canvas coordinates
        self.bbox_side = bbox_side
        self.num_sides = num_sides
        self.side_length = None
        self.apothem = None
        self._calc_side_length()
        self.points = [Point(x - self.side_length // 2, y - self.apothem)]
        self._make_points()
        self.lines = []
        self._make_lines()

    def _calc_side_length(self):
        """Side length given the radius (circumradius):
        i/e the distance from the center to a vertex
        """
        self.side_length = 2 * (self.bbox_side // 2) * math.sin(math.pi / self.num_sides)

        # Apothem, i/e distance from the center of the polygon 
        # to the midpoint of any side, given the side length 
        self.apothem = self.side_length / (2 * math.tan(math.pi / self.num_sides))

    def _make_points(self):
        _angle = 2 * math.pi / self.num_sides
        for pdx in range(self.num_sides):
            angle = _angle * pdx
            _x = math.cos(angle) * self.side_length
            _y = math.sin(angle) * self.side_length
            self.points.append(self.points[-1] + Point(_x, _y))

    def _make_lines(self):
        for p0, p1 in zip(self.points[:-1], self.points[1:]):
            self.lines.append((*p0, *p1))

    def draw(self, canvas):
        #for line in self.lines:
        
        canvas.create_polygon(self.lines,fill="blue")
            #canvas.create_line(line)
        # alternatively, use canvas.create_polygon(points coordinates) instead


    
    
def draw_cook_times(canvas,cook1,cook2,cool1,cool2,cool3,times,manual_status,manual_times):
    '''
    canvas is the area to draw the layout
    width & height is current dimensions of the canvas (allows scaling with window)
    times is an array of cook/cool times remaining with [0] being cook,[1] being cool 1 etc.
    '''
    colour = 'grey'
    outline_colour = 'black'
    #text update
    #first draw text a little bit bigger behind to give it an outline 
    #heat
    
   
    
    if times[1]!=0:
        cook1.draw_dial(times[0],"Cook 1:\n{0:.2f}".format(times[0]))
        cook2.draw_dial(times[1],"Cook 2:\n{0:.2f}".format(times[1]))
    else:
        cook1.draw_dial(times[0],"Cook 1:\n{0:.2f}".format(times[0]))
    
    #cool 1
    if manual_status[0]==0:
        cool1.draw_dial(times[2],"Cool 1:\n{0:.2f}".format(times[2]))
    else:
        cool1.draw_dial(manual_times[0],"!Manual!\nCool 1:\n{0:.2f}".format(manual_times[0]))
        
    #cool 2
    if manual_status[1]==0:
        cool2.draw_dial(times[3],"Cool 2:\n{0:.2f}".format(times[3]))
    else:
        cool2.draw_dial(manual_times[1],"!Manual!\nCool 2:\n{0:.2f}".format(manual_times[1]))
        
    #cool 3
    if manual_status[2]==0:
        cool3.draw_dial(times[4],"Cool 3:\n{0:.2f}".format(times[4]))
    else:
        cool3.draw_dial(manual_times[2],"!Manual!\nCool 3:\n{0:.2f}".format(manual_times[2]))

   

#def oven_temp(canvas,width,height,temp):
#    #canvas.create_rectangle(width-200,50,width-300,60,fill="blue")
#    draw_dial(canvas, [200,200,width-270,200], _w1.can60.winfo_width(),_w1.can60.winfo_height(), 360, 0, temp,"Temp:\n{0:.0f}".format(temp),thickness=30,dial_type = "semi_circle")
 
    
def draw_time(canvas):
    canvas.create_text(240,200,text=date.today().strftime("%b-%d-%Y")+"\n"+datetime.now().strftime("%H:%M:%S"),justify='center',fill=text_colour,font="Times 50 bold")


    
def draw_turret_2(canvas,width,height,arm_numbers):
    #centre = (width/2,height/2)
    centre = (width/2,height/2)
    arm_width=20
    mould_width=100
    TEXT = [[250,110,arm_numbers[0]],
            [120,250,arm_numbers[1]],
            [250,380,arm_numbers[2]],
            [380,250,arm_numbers[3]]]
 
    for x in TEXT:
        x[0]+=centre[0]-250
        x[1]+=centre[1]-250
        canvas.create_text(x[0],x[1],text="ARM\n{}".format(x[2]),justify='center',fill=text_colour,font = "Times 30 bold")

def draw_scanner_zones(canvas,width,height,warning_zones,danger_zones):
   
    '''
    canvas is the area to draw the layout
    width & height is current dimensions of the canvas (allows scaling with window)
    warning_zones is a binary value associated with each zone (1 for active)
    danger_zones is the same as above but for danger zones.
    '''
 
    x_start = 200
    
    center = ((width)/2,(height)/2)
    width_margin =(width - height)/2
    height_margin =50
    warn_colour = "yellow"
    danger_colour = "red"
    none_colour = scanner_neutral
    
    shift = 100
    
    #scanner zones
    if warning_zones[0]!=1:
        #cool 1 warning zone
        canvas.create_arc(width_margin, 0,width-width_margin, height-height_margin, start=135,
        extent=90, fill=warn_colour)
    else:
        canvas.create_arc(width_margin, 0,width-width_margin, height-height_margin, start=135,
        extent=90, fill=none_colour)
        
    if warning_zones[1]!=1:
        #cool 2 warning_zone
        canvas.create_arc(width_margin,0 ,width-width_margin, height-height_margin, start=225,
        extent=90, fill=warn_colour)
    else:
        canvas.create_arc(width_margin,0 ,width-width_margin, height-height_margin, start=225,
        extent=90, fill=none_colour)
                      
    #cool 3 warning zone
    if warning_zones[2]!=1:
        canvas.create_arc(width_margin,0 ,width-width_margin, height-height_margin, start=315,
        extent=90, fill=warn_colour)
    else:
        canvas.create_arc(width_margin,0 ,width-width_margin, height-height_margin, start=315,
        extent=90, fill=none_colour)
        
    if danger_zones[0]!=1:             
        #cool 1 safety zone
        canvas.create_arc(width_margin+shift, shift,(width-width_margin)-shift, (height-height_margin)-shift, start=135,
        extent=90, fill=danger_colour)
    else:
        canvas.create_arc(width_margin+shift, shift,(width-width_margin)-shift, (height-height_margin)-shift, start=135,
        extent=90, fill=none_colour)

    if danger_zones[1]!=1:  
        #cool 2 safety zone
        canvas.create_arc(width_margin+shift, shift,(width-width_margin)-shift, (height-height_margin)-shift, start=225,
        extent=90, fill=danger_colour)
    else:
        canvas.create_arc(width_margin+shift, shift,(width-width_margin)-shift, (height-height_margin)-shift, start=225,
        extent=90, fill=none_colour)
                      
    #cool 3 safety zone
    if danger_zones[2]!=1:
        canvas.create_arc(width_margin+shift, shift,(width-width_margin)-shift, (height-height_margin)-shift, start=315,
        extent=90, fill=danger_colour)
    else:
        canvas.create_arc(width_margin+shift, shift,(width-width_margin)-shift, (height-height_margin)-shift, start=315,
        extent=90, fill=none_colour)
        
def status_indicator(canvas,width,height,values):
    colour = "red"
    if values[0]==1:
         #cool 1
         canvas.create_text(250,height-300,text="UNLOAD 1",justify='center',fill=colour,font="Times 50 bold")
    if values[1]==1:
       #cool 2
        canvas.create_text(250,height-200,text="UNLOAD 2",justify='center',fill=colour,font="Times 50 bold")

    if values[2]==1:
        #cool 3
        canvas.create_text(250,height-100,text="UNLOAD 3",justify='center',fill=colour,font="Times 50 bold")

def alarm_indicator(canvas,width,height,alarms):
    error = "red"
    center = [width-250, height-300]
    if alarms[1]==1:
        canvas.create_text(center[0],center[1],text="!! ALARM !!! ",justify='center',fill='red',font="Times 50 bold")
    if alarms[2]==1:
        canvas.create_text(center[0],center[1]+100,text="!! SCANNER ERROR !!",justify='center',fill='yellow',font="Times 30 bold")
    
    
    
def scanner_indicator(canvas,width,height,error_values):
    error = "red"
    good = "green"
    center = [width-250, height-300]
    
    if error_values[0] == 1:
        canvas.create_text(center[0],center[1],text="SCANNER 1: ERR\nCLEAN",justify='center',fill=error,font="Times 30 bold")
    else:
        canvas.create_text(center[0],center[1],text="SCANNER 1: OK",justify='center',fill=good,font="Times 30 bold")
    if error_values[1] == 1:
        canvas.create_text(center[0],center[1]+100,text="SCANNER 2: ERR\nCLEAN",justify='center',fill=error,font="Times 30 bold")
    else:
        canvas.create_text(center[0],center[1]+100,text="SCANNER 2: OK",justify='center',fill=good,font="Times 30 bold")
    if error_values[2] == 1:
        canvas.create_text(center[0],center[1]+200,text="SCANNER 3: ERR\nCLEAN",justify='center',fill=error,font="Times 30 bold")
    else:
        canvas.create_text(center[0],center[1]+200,text="SCANNER 3: OK",justify='center',fill=good,font="Times 30 bold")
    
def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
   
    _w1 = OVEN.Toplevel1(_top1)
    x=0

    y=60
    
    #connect to PLC
    CPU_plc = PLC("192.168.3.250",1026)
    
    width = 100
    height=100
    while True:
        
        _top1.update_idletasks()
        _top1.update()
        #clear canvas to prevent memory leaks.
        _w1.can60.delete("all")
        plc_status = CPU_plc.read_m_bits("SM8000",3)
        _w1.can60.configure(background=bck_colour)
        width = _w1.can60.winfo_width()
        height = _w1.can60.winfo_height()
        canvas = _w1.can60
     
        #change colours
        dial_cook1 = dial_guage(_w1.can60, 200,200, width/2-200,150, 60, 0,txt_colour=text_colour,bg_colour=bck_colour)
        dial_cook2 = dial_guage(_w1.can60, 200,200, width/2+200,150, 60, 0,txt_colour=text_colour,bg_colour=bck_colour)
        dial_cool1 = dial_guage(_w1.can60, 200,200, 270, height/2, 60, 0,txt_colour=text_colour,bg_colour=bck_colour)
        dial_cool2 = dial_guage(_w1.can60,200,200,width/2,height-150, 60, 0,txt_colour=text_colour,bg_colour=bck_colour)
        dial_cool3 = dial_guage(_w1.can60, 200,200,width-270,height/2, 60, 0,txt_colour=text_colour,bg_colour=bck_colour)
        dial_temp = dial_guage(_w1.can60, 200,200,width-270,200, 360, 0,dial_type = "semi_circle",txt_colour=text_colour,bg_colour=bck_colour)
        
        cook_times = [0,0,0,0,0]
        warning_zones = [0,0,0]
        danger_zones = [0,0,0]
        unload = [0,0,0]
        
        #######################################################################################
        ####                                                                               ####
        ####                                                                               ####
        ####                            Read values from PLC                               ####
        ####                                                                               ####
        ####                                                                               ####
        #######################################################################################
        
        X = CPU_plc.read_input_value()
        #read in cook time data
        if CPU_plc.read_word_value("D271")!=0:
            cook_times[0] = CPU_plc.read_word_value("D5006")*0.016667-CPU_plc.read_word_value("D271")*0.016667
        else:
            cook_times[0] = 0
        if CPU_plc.read_word_value("D272")!=0:
            cook_times[1] = CPU_plc.read_word_value("D5008")*0.016667-CPU_plc.read_word_value("D272")*0.016667
        else:
            cook_times[1] = 0
        cook_times[2] = CPU_plc.read_word_value("D309")*0.016667
        cook_times[3] = CPU_plc.read_word_value("D306")*0.016667
        cook_times[4] = CPU_plc.read_word_value("D303")*0.016667

        cook_times[2] = CPU_plc.read_word_value("D309")*0.016667
        cook_times[2] = CPU_plc.read_word_value("D309")*0.016667
        cook_times[2] = CPU_plc.read_word_value("D309")*0.016667

        manual_times = [0,0,0]
        manual_times[0] = CPU_plc.read_word_value("D4500")*0.016667
        manual_times[1] = CPU_plc.read_word_value("D4504")*0.016667
        manual_times[2] = CPU_plc.read_word_value("D4508")*0.016667

        manual_rotate = [0,0,0]
        
        manual_rotate[0] = CPU_plc.read_m_bits("M300",3)[0]
        manual_rotate[1] = CPU_plc.read_m_bits("M215",3)[0]
        manual_rotate[2] = CPU_plc.read_m_bits("M175",3)[0]
        
        
        unload = CPU_plc.read_m_bits("M1630",3)
        alarm_warning = CPU_plc.read_m_bits("Y107",3)
        
        alarms = CPU_plc.read_m_bits("M3000",3)
       
        scanner_status = [X[112],X[117],X[120]]
   

        warning_zones[0] = X[113]
        warning_zones[1] = X[118]
        warning_zones[2] = X[121]

        danger_zones[0] = X[114]
        danger_zones[1] = X[119]
        danger_zones[2] = X[122]

        temp = CPU_plc.read_word_value("D1")
        
        #######################################################################################
        ####                                                                               ####
        ####                                                                               ####
        ####                      Adjust dials to new window dimensions                    ####
        ####                                                                               ####
        ####                                                                               ####
        #######################################################################################
        
        #update positions of dial guages
        if cook_times[1]!=0:
            dial_cook1.update_dial(_w1.can60,width/2-200,150)
            dial_cook2.update_dial(_w1.can60,width/2+200,150)
        else:
            dial_cook1.update_dial(_w1.can60,width/2,150)
        
        dial_cool1.update_dial(_w1.can60,270, height/2)
        dial_cool2.update_dial(_w1.can60,width/2,height-150)
        dial_cool3.update_dial(_w1.can60,width-270,height/2)
        dial_temp.update_dial(_w1.can60,width-270,200)
        
        
        #######################################################################################
        ####                                                                               ####
        ####                                                                               ####
        ####                               draw everything                                 ####
        ####                                                                               ####
        ####                                                                               ####
        #######################################################################################
        
        
        #draw the scanners
        draw_scanner_zones(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height(),warning_zones,danger_zones)
        
        #draw the cook/cool times.
        draw_cook_times(canvas,dial_cook1,dial_cook2,dial_cool1,dial_cool2,dial_cool3,cook_times,manual_rotate,manual_times)
        
        #Draw oven temp on the display
        #oven_temp(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height(),temp)
        dial_temp.draw_dial( temp,"Temp:\n{0:.0f}".format(temp))
        #Adds time/date to display
        draw_time(_w1.can60)
        #if PLC isnt running display error
        CENTER = Point(_w1.can60.winfo_width() // 2, _w1.can60.winfo_height() // 2)
        p = RegularPolygon(8, 400, *CENTER)
            
        Arm_oven = CPU_plc.read_word_value("D7")
        Arm_cool1 = CPU_plc.read_word_value("D8")
        Arm_cool2 = CPU_plc.read_word_value("D11")
        Arm_cool3 = CPU_plc.read_word_value("D9")
        
        arm_numbers=[Arm_oven,Arm_cool1,Arm_cool2,Arm_cool3]

        
        #draw the turret
        #draw_turret_2(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height(),arm_numbers)

        #draw UNLOAD indicator
        status_indicator(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height(),unload)

        #show scanner errors
        #scanner_indicator(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height(),scanner_status)
        alarm_indicator(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height(),alarms)                 
        #status_indicator(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height())
        #check how many connection errors happened if to many reset it.
        
        CPU_plc.check_connect()
        p.draw(_w1.can60)
        draw_turret_2(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height(),arm_numbers)
        if  plc_status[0]!=1:
            draw_PLC_error(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height())

        if alarm_warning[0]==1:
            draw_alarm_alert(_w1.can60,_w1.can60.winfo_width(),_w1.can60.winfo_height()) 
        
if __name__ == '__main__':
    OVEN.start_up()




